/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DOCUMENT } from '@angular/common';
import { HttpBackend, HttpClient } from '@angular/common/http';
import { Inject, Optional, RendererFactory2, SecurityContext } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { catchError, finalize, map, share, tap } from 'rxjs/operators';
import { cloneSVG, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, replaceFillColor, withSuffix, withSuffixAndColor } from '../utils';
import { HttpModuleNotImport, IconNotFoundError, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError } from './icon.error';
var IconService = /** @class */ (function () {
    function IconService(_rendererFactory, _handler, _document, sanitizer) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.sanitizer = sanitizer;
        this.defaultTheme = 'outline';
        /**
         * All icon definitions would be registered here.
         */
        this._svgDefinitions = new Map();
        /**
         * Cache all rendered icons. Icons are identified by name, theme,
         * and for twotone icons, primary color and secondary color.
         */
        this._svgRenderedDefinitions = new Map();
        this._inProgressFetches = new Map();
        /**
         * Url prefix for fetching inline SVG by dynamic importing.
         */
        this._assetsUrlRoot = '';
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    Object.defineProperty(IconService.prototype, "twoToneColor", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (tslib_1.__assign({}, this._twoToneColorPalette))); // Make a copy to avoid unexpected changes.
        },
        set: /**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var primaryColor = _a.primaryColor, secondaryColor = _a.secondaryColor;
            this._twoToneColorPalette.primaryColor = primaryColor;
            this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param prefix
     */
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param {?} prefix
     * @return {?}
     */
    IconService.prototype.changeAssetsSource = /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    };
    /**
     * Add icons provided by ant design.
     * @param icons
     */
    /**
     * Add icons provided by ant design.
     * @param {...?} icons
     * @return {?}
     */
    IconService.prototype.addIcon = /**
     * Add icons provided by ant design.
     * @param {...?} icons
     * @return {?}
     */
    function () {
        var _this = this;
        var icons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            icons[_i] = arguments[_i];
        }
        icons.forEach(function (icon) {
            _this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    };
    /**
     * Register an icon. Namespace is required.
     * @param type
     * @param literal
     */
    /**
     * Register an icon. Namespace is required.
     * @param {?} type
     * @param {?} literal
     * @return {?}
     */
    IconService.prototype.addIconLiteral = /**
     * Register an icon. Namespace is required.
     * @param {?} type
     * @param {?} literal
     * @return {?}
     */
    function (type, literal) {
        var _a = tslib_1.__read(getNameAndNamespace(type), 2), name = _a[0], namespace = _a[1];
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    };
    /**
     * Remove all cache.
     */
    /**
     * Remove all cache.
     * @return {?}
     */
    IconService.prototype.clear = /**
     * Remove all cache.
     * @return {?}
     */
    function () {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    };
    /**
     * Get a rendered `SVGElement`.
     * @param icon
     * @param twoToneColor
     */
    /**
     * Get a rendered `SVGElement`.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype.getRenderedContent = /**
     * Get a rendered `SVGElement`.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        var _this = this;
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        /** @type {?} */
        var definition = isIconDefinition(icon) ? (/** @type {?} */ (icon)) : this._svgDefinitions.get((/** @type {?} */ (icon)));
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`. Otherwise try to fetch it from remote.
        /** @type {?} */
        var $iconDefinition = definition ? observableOf(definition) : this._getFromRemote((/** @type {?} */ (icon)));
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map(function (i) {
            if (!i) {
                throw IconNotFoundError((/** @type {?} */ (icon)));
            }
            return _this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        }));
    };
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @param type
     */
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @protected
     * @param {?} type
     * @return {?}
     */
    IconService.prototype._getFromRemote = /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @protected
     * @param {?} type
     * @return {?}
     */
    function (type) {
        var _this = this;
        if (!this._http) {
            return observableOf(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time, http request should only be fired once.
        /** @type {?} */
        var inProgress = this._inProgressFetches.get(type);
        // If there's no other directive asking for the same icon, fire a request.
        if (!inProgress) {
            var _a = tslib_1.__read(getNameAndNamespace(type), 2), name_1 = _a[0], namespace = _a[1];
            // If the string has a namespace within, create a simple `IconDefinition`.
            /** @type {?} */
            var icon_1 = namespace
                ? { name: name_1, icon: '' }
                : getIconDefinitionFromAbbr(name_1);
            /** @type {?} */
            var url = namespace
                ? this._assetsUrlRoot + "assets/" + namespace + "/" + icon_1.name + ".svg"
                : this._assetsUrlRoot + "assets/" + icon_1.theme + "/" + icon_1.name + ".svg";
            /** @type {?} */
            var safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            // Wrap a `IconDefinition`, cache it, delete the shared work.
            inProgress = this._http.get(safeUrl, { responseType: 'text' }).pipe(map(function (literal) { return (tslib_1.__assign({}, icon_1, { icon: literal })); }), tap(function (definition) { return _this.addIcon(definition); }), finalize(function () { return _this._inProgressFetches.delete(type); }), catchError(function () { return observableOf(null); }), share());
            this._inProgressFetches.set(type, inProgress);
        }
        // Otherwise just reuse other directive's request.
        return inProgress;
    };
    /**
     * Render a new `SVGElement` for given `IconDefinition`, or make a copy from cache.
     * @param icon
     * @param twoToneColor
     */
    /**
     * Render a new `SVGElement` for given `IconDefinition`, or make a copy from cache.
     * @protected
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype._loadSVGFromCacheOrCreateNew = /**
     * Render a new `SVGElement` for given `IconDefinition`, or make a copy from cache.
     * @protected
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        /** @type {?} */
        var svg;
        /** @type {?} */
        var pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        var sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        var key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined ? icon.name : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        /** @type {?} */
        var cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, (/** @type {?} */ (tslib_1.__assign({}, icon, { icon: svg }))));
        }
        return cloneSVG(svg);
    };
    /**
     * @protected
     * @param {?} str
     * @return {?}
     */
    IconService.prototype._createSVGElementFromString = /**
     * @protected
     * @param {?} str
     * @return {?}
     */
    function (str) {
        /** @type {?} */
        var div = this._document.createElement('div');
        div.innerHTML = str;
        /** @type {?} */
        var svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    };
    /**
     * @protected
     * @param {?} svg
     * @return {?}
     */
    IconService.prototype._setSVGAttribute = /**
     * @protected
     * @param {?} svg
     * @return {?}
     */
    function (svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    };
    /**
     * @protected
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    IconService.prototype._colorizeSVGIcon = /**
     * @protected
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    function (svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            var children = svg.childNodes;
            /** @type {?} */
            var length_1 = children.length;
            for (var i = 0; i < length_1; i++) {
                /** @type {?} */
                var child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    };
    /** @nocollapse */
    IconService.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: HttpBackend, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
        { type: DomSanitizer }
    ]; };
    return IconService;
}());
export { IconService };
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._renderer;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._http;
    /**
     * All icon definitions would be registered here.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgDefinitions;
    /**
     * Cache all rendered icons. Icons are identified by name, theme,
     * and for twotone icons, primary color and secondary color.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgRenderedDefinitions;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._inProgressFetches;
    /**
     * Url prefix for fetching inline SVG by dynamic importing.
     * @type {?}
     * @protected
     */
    IconService.prototype._assetsUrlRoot;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._twoToneColorPalette;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._rendererFactory;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._handler;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._document;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype.sanitizer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBYSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0YsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxFQUFFLElBQUksWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkUsT0FBTyxFQUNMLFFBQVEsRUFDUix5QkFBeUIsRUFDekIsbUJBQW1CLEVBQ25CLGlCQUFpQixFQUNqQixZQUFZLEVBQ1osZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixVQUFVLEVBQ1Ysa0JBQWtCLEVBQ25CLE1BQU0sVUFBVSxDQUFDO0FBQ2xCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSwwQkFBMEIsRUFBRSxtQkFBbUIsRUFBRSxlQUFlLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFeEk7SUFzQ0UscUJBQ1ksZ0JBQWtDLEVBQ3RCLFFBQXFCLEVBRUgsU0FBYyxFQUM1QyxTQUF1QjtRQUp2QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ3RCLGFBQVEsR0FBUixRQUFRLENBQWE7UUFFSCxjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQzVDLGNBQVMsR0FBVCxTQUFTLENBQWM7UUExQ25D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LENBQUM7aUJBQ2pEO2FBQ0Y7U0FDRjtRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDekQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDOzs7Z0JBek9tQyxnQkFBZ0I7Z0JBRDdDLFdBQVcsdUJBMkRmLFFBQVE7Z0RBRVIsUUFBUSxZQUFJLE1BQU0sU0FBQyxRQUFRO2dCQTNEdkIsWUFBWTs7SUF5T3JCLGtCQUFDO0NBQUEsQUF4TkQsSUF3TkM7U0F4TlksV0FBVzs7O0lBQ3RCLG1DQUFvQzs7Ozs7SUFFcEMsZ0NBQStCOzs7OztJQUMvQiw0QkFBNEI7Ozs7OztJQUs1QixzQ0FBOEQ7Ozs7Ozs7SUFNOUQsOENBQTRFOzs7OztJQUU1RSx5Q0FBb0Y7Ozs7OztJQUtwRixxQ0FBOEI7Ozs7O0lBRTlCLDJDQUdFOzs7OztJQVlBLHVDQUE0Qzs7Ozs7SUFDNUMsK0JBQTJDOzs7OztJQUUzQyxnQ0FBc0Q7Ozs7O0lBQ3RELGdDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEh0dHBCYWNrZW5kLCBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0LCBPcHRpb25hbCwgUmVuZGVyZXIyLCBSZW5kZXJlckZhY3RvcnkyLCBTZWN1cml0eUNvbnRleHQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbVNhbml0aXplciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgb2YgYXMgb2JzZXJ2YWJsZU9mLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBmaW5hbGl6ZSwgbWFwLCBzaGFyZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FjaGVkSWNvbkRlZmluaXRpb24sIEljb25EZWZpbml0aW9uLCBUaGVtZVR5cGUsIFR3b1RvbmVDb2xvclBhbGV0dGUsIFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBjbG9uZVNWRyxcbiAgZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicixcbiAgZ2V0TmFtZUFuZE5hbWVzcGFjZSxcbiAgZ2V0U2Vjb25kYXJ5Q29sb3IsXG4gIGhhc05hbWVzcGFjZSxcbiAgaXNJY29uRGVmaW5pdGlvbixcbiAgcmVwbGFjZUZpbGxDb2xvcixcbiAgd2l0aFN1ZmZpeCxcbiAgd2l0aFN1ZmZpeEFuZENvbG9yXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEh0dHBNb2R1bGVOb3RJbXBvcnQsIEljb25Ob3RGb3VuZEVycm9yLCBOYW1lU3BhY2VJc05vdFNwZWNpZnlFcnJvciwgU1ZHVGFnTm90Rm91bmRFcnJvciwgVXJsTm90U2FmZUVycm9yIH0gZnJvbSAnLi9pY29uLmVycm9yJztcblxuZXhwb3J0IGNsYXNzIEljb25TZXJ2aWNlIHtcbiAgZGVmYXVsdFRoZW1lOiBUaGVtZVR5cGUgPSAnb3V0bGluZSc7XG5cbiAgcHJvdGVjdGVkIF9yZW5kZXJlcjogUmVuZGVyZXIyO1xuICBwcm90ZWN0ZWQgX2h0dHA6IEh0dHBDbGllbnQ7XG5cbiAgLyoqXG4gICAqIEFsbCBpY29uIGRlZmluaXRpb25zIHdvdWxkIGJlIHJlZ2lzdGVyZWQgaGVyZS5cbiAgICovXG4gIHByb3RlY3RlZCBfc3ZnRGVmaW5pdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgSWNvbkRlZmluaXRpb24+KCk7XG5cbiAgLyoqXG4gICAqIENhY2hlIGFsbCByZW5kZXJlZCBpY29ucy4gSWNvbnMgYXJlIGlkZW50aWZpZWQgYnkgbmFtZSwgdGhlbWUsXG4gICAqIGFuZCBmb3IgdHdvdG9uZSBpY29ucywgcHJpbWFyeSBjb2xvciBhbmQgc2Vjb25kYXJ5IGNvbG9yLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zdmdSZW5kZXJlZERlZmluaXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIENhY2hlZEljb25EZWZpbml0aW9uPigpO1xuXG4gIHByb3RlY3RlZCBfaW5Qcm9ncmVzc0ZldGNoZXMgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+PigpO1xuXG4gIC8qKlxuICAgKiBVcmwgcHJlZml4IGZvciBmZXRjaGluZyBpbmxpbmUgU1ZHIGJ5IGR5bmFtaWMgaW1wb3J0aW5nLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9hc3NldHNVcmxSb290ID0gJyc7XG5cbiAgcHJvdGVjdGVkIF90d29Ub25lQ29sb3JQYWxldHRlOiBUd29Ub25lQ29sb3JQYWxldHRlID0ge1xuICAgIHByaW1hcnlDb2xvciAgOiAnIzMzMzMzMycsXG4gICAgc2Vjb25kYXJ5Q29sb3I6ICcjRTZFNkU2J1xuICB9O1xuXG4gIHNldCB0d29Ub25lQ29sb3IoeyBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yIH06IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIpIHtcbiAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnByaW1hcnlDb2xvciA9IHByaW1hcnlDb2xvcjtcbiAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnNlY29uZGFyeUNvbG9yID0gc2Vjb25kYXJ5Q29sb3IgfHwgZ2V0U2Vjb25kYXJ5Q29sb3IocHJpbWFyeUNvbG9yKTtcbiAgfVxuXG4gIGdldCB0d29Ub25lQ29sb3IoKTogVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlciB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZSB9IGFzIFR3b1RvbmVDb2xvclBhbGV0dGU7IC8vIE1ha2UgYSBjb3B5IHRvIGF2b2lkIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBfcmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyLFxuICAgIEBPcHRpb25hbCgpIHByb3RlY3RlZCBfaGFuZGxlcjogSHR0cEJhY2tlbmQsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBfZG9jdW1lbnQ6IGFueSxcbiAgICBwcm90ZWN0ZWQgc2FuaXRpemVyOiBEb21TYW5pdGl6ZXJcbiAgKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2h0dHAgPSBuZXcgSHR0cENsaWVudCh0aGlzLl9oYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBwcmVmaXggb2YgdGhlIGlubGluZSBzdmcgcmVzb3VyY2VzLCBzbyB0aGV5IGNvdWxkIGJlIGRlcGxveWVkIGVsc2V3aGVyZSwgbGlrZSBDRE4uXG4gICAqIEBwYXJhbSBwcmVmaXhcbiAgICovXG4gIGNoYW5nZUFzc2V0c1NvdXJjZShwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2Fzc2V0c1VybFJvb3QgPSBwcmVmaXguZW5kc1dpdGgoJy8nKSA/IHByZWZpeCA6IHByZWZpeCArICcvJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgaWNvbnMgcHJvdmlkZWQgYnkgYW50IGRlc2lnbi5cbiAgICogQHBhcmFtIGljb25zXG4gICAqL1xuICBhZGRJY29uKC4uLmljb25zOiBJY29uRGVmaW5pdGlvbltdKTogdm9pZCB7XG4gICAgaWNvbnMuZm9yRWFjaChpY29uID0+IHtcbiAgICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLnNldCh3aXRoU3VmZml4KGljb24ubmFtZSwgaWNvbi50aGVtZSksIGljb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGljb24uIE5hbWVzcGFjZSBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHR5cGVcbiAgICogQHBhcmFtIGxpdGVyYWxcbiAgICovXG4gIGFkZEljb25MaXRlcmFsKHR5cGU6IHN0cmluZywgbGl0ZXJhbDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWyBuYW1lLCBuYW1lc3BhY2UgXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgIHRocm93IE5hbWVTcGFjZUlzTm90U3BlY2lmeUVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkSWNvbih7IG5hbWU6IHR5cGUsIGljb246IGxpdGVyYWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjYWNoZS5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5fc3ZnUmVuZGVyZWREZWZpbml0aW9ucy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlbmRlcmVkIGBTVkdFbGVtZW50YC5cbiAgICogQHBhcmFtIGljb25cbiAgICogQHBhcmFtIHR3b1RvbmVDb2xvclxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDb250ZW50KGljb246IEljb25EZWZpbml0aW9uIHwgc3RyaW5nLCB0d29Ub25lQ29sb3I/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICAvLyBJZiBgaWNvbmAgaXMgYSBgSWNvbkRlZmluaXRpb25gLCBnbyB0byB0aGUgbmV4dCBzdGVwLiBJZiBub3QsIHRyeSB0byBmZXRjaCBpdCBmcm9tIGNhY2hlLlxuICAgIGNvbnN0IGRlZmluaXRpb246IEljb25EZWZpbml0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZCA9IGlzSWNvbkRlZmluaXRpb24oaWNvbikgPyBpY29uIGFzIEljb25EZWZpbml0aW9uIDogdGhpcy5fc3ZnRGVmaW5pdGlvbnMuZ2V0KGljb24gYXMgc3RyaW5nKTtcblxuICAgIC8vIElmIGBpY29uYCBpcyBhIGBJY29uRGVmaW5pdGlvbmAgb2Ygc3VjY2Vzc2Z1bGx5IGZldGNoLCB3cmFwIGl0IGluIGFuIGBPYnNlcnZhYmxlYC4gT3RoZXJ3aXNlIHRyeSB0byBmZXRjaCBpdCBmcm9tIHJlbW90ZS5cbiAgICBjb25zdCAkaWNvbkRlZmluaXRpb24gPSBkZWZpbml0aW9uID8gb2JzZXJ2YWJsZU9mKGRlZmluaXRpb24pIDogdGhpcy5fZ2V0RnJvbVJlbW90ZShpY29uIGFzIHN0cmluZyk7XG5cbiAgICAvLyBJZiBmaW5hbGx5IGdldCBhbiBgSWNvbkRlZmluaXRpb25gLCByZW5kZXIgYW5kIHJldHVybiBpdC4gT3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiAkaWNvbkRlZmluaXRpb24ucGlwZShtYXAoaSA9PiB7XG4gICAgICBpZiAoIWkpIHsgdGhyb3cgSWNvbk5vdEZvdW5kRXJyb3IoaWNvbiBhcyBzdHJpbmcpOyB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGksIHR3b1RvbmVDb2xvcik7XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCByYXcgc3ZnIGFuZCBhc3NlbWJsZSBhIGBJY29uRGVmaW5pdGlvbmAgb2JqZWN0LlxuICAgKiBAcGFyYW0gdHlwZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRGcm9tUmVtb3RlKHR5cGU6IHN0cmluZyk6IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24gfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLl9odHRwKSB7IHJldHVybiBvYnNlcnZhYmxlT2YoSHR0cE1vZHVsZU5vdEltcG9ydCgpKTsgfVxuXG4gICAgLy8gSWYgbXVsdGkgZGlyZWN0aXZlIGFzayBmb3IgdGhlIHNhbWUgaWNvbiBhdCB0aGUgc2FtZSB0aW1lLCBodHRwIHJlcXVlc3Qgc2hvdWxkIG9ubHkgYmUgZmlyZWQgb25jZS5cbiAgICBsZXQgaW5Qcm9ncmVzcyA9IHRoaXMuX2luUHJvZ3Jlc3NGZXRjaGVzLmdldCh0eXBlKTtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3RoZXIgZGlyZWN0aXZlIGFza2luZyBmb3IgdGhlIHNhbWUgaWNvbiwgZmlyZSBhIHJlcXVlc3QuXG4gICAgaWYgKCFpblByb2dyZXNzKSB7XG4gICAgICBjb25zdCBbIG5hbWUsIG5hbWVzcGFjZSBdID0gZ2V0TmFtZUFuZE5hbWVzcGFjZSh0eXBlKTtcblxuICAgICAgLy8gSWYgdGhlIHN0cmluZyBoYXMgYSBuYW1lc3BhY2Ugd2l0aGluLCBjcmVhdGUgYSBzaW1wbGUgYEljb25EZWZpbml0aW9uYC5cbiAgICAgIGNvbnN0IGljb246IEljb25EZWZpbml0aW9uID0gbmFtZXNwYWNlXG4gICAgICAgID8geyBuYW1lLCBpY29uOiAnJyB9XG4gICAgICAgIDogZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicihuYW1lKTtcblxuICAgICAgY29uc3QgdXJsID0gbmFtZXNwYWNlXG4gICAgICAgID8gYCR7dGhpcy5fYXNzZXRzVXJsUm9vdH1hc3NldHMvJHtuYW1lc3BhY2V9LyR7aWNvbi5uYW1lfS5zdmdgXG4gICAgICAgIDogYCR7dGhpcy5fYXNzZXRzVXJsUm9vdH1hc3NldHMvJHtpY29uLnRoZW1lfS8ke2ljb24ubmFtZX0uc3ZnYDtcblxuICAgICAgY29uc3Qgc2FmZVVybCA9IHRoaXMuc2FuaXRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5VUkwsIHVybCk7XG5cbiAgICAgIGlmICghc2FmZVVybCkgeyB0aHJvdyBVcmxOb3RTYWZlRXJyb3IodXJsKTsgfVxuXG4gICAgICAvLyBXcmFwIGEgYEljb25EZWZpbml0aW9uYCwgY2FjaGUgaXQsIGRlbGV0ZSB0aGUgc2hhcmVkIHdvcmsuXG4gICAgICBpblByb2dyZXNzID0gdGhpcy5faHR0cC5nZXQoc2FmZVVybCwgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KS5waXBlKFxuICAgICAgICBtYXAobGl0ZXJhbCA9PiAoeyAuLi5pY29uLCBpY29uOiBsaXRlcmFsIH0pKSxcbiAgICAgICAgdGFwKGRlZmluaXRpb24gPT4gdGhpcy5hZGRJY29uKGRlZmluaXRpb24pKSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5faW5Qcm9ncmVzc0ZldGNoZXMuZGVsZXRlKHR5cGUpKSxcbiAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvYnNlcnZhYmxlT2YobnVsbCkpLFxuICAgICAgICBzaGFyZSgpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9pblByb2dyZXNzRmV0Y2hlcy5zZXQodHlwZSwgaW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV1c2Ugb3RoZXIgZGlyZWN0aXZlJ3MgcmVxdWVzdC5cbiAgICByZXR1cm4gaW5Qcm9ncmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgYFNWR0VsZW1lbnRgIGZvciBnaXZlbiBgSWNvbkRlZmluaXRpb25gLCBvciBtYWtlIGEgY29weSBmcm9tIGNhY2hlLlxuICAgKiBAcGFyYW0gaWNvblxuICAgKiBAcGFyYW0gdHdvVG9uZUNvbG9yXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xvYWRTVkdGcm9tQ2FjaGVPckNyZWF0ZU5ldyhpY29uOiBJY29uRGVmaW5pdGlvbiwgdHdvVG9uZUNvbG9yPzogc3RyaW5nKTogU1ZHRWxlbWVudCB7XG4gICAgbGV0IHN2ZzogU1ZHRWxlbWVudDtcblxuICAgIGNvbnN0IHByaSA9IHR3b1RvbmVDb2xvciB8fCB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnByaW1hcnlDb2xvcjtcbiAgICBjb25zdCBzZWMgPSBnZXRTZWNvbmRhcnlDb2xvcihwcmkpIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3I7XG4gICAgY29uc3Qga2V5ID0gaWNvbi50aGVtZSA9PT0gJ3R3b3RvbmUnXG4gICAgICA/IHdpdGhTdWZmaXhBbmRDb2xvcihpY29uLm5hbWUsIGljb24udGhlbWUsIHByaSwgc2VjKVxuICAgICAgOiBpY29uLnRoZW1lID09PSB1bmRlZmluZWQgPyBpY29uLm5hbWUgOiB3aXRoU3VmZml4KGljb24ubmFtZSwgaWNvbi50aGVtZSk7XG5cbiAgICAvLyBUcnkgdG8gbWFrZSBhIGNvcHkgZnJvbSBjYWNoZS5cbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdmdSZW5kZXJlZERlZmluaXRpb25zLmdldChrZXkpO1xuXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgc3ZnID0gY2FjaGVkLmljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN2ZyA9IHRoaXMuX3NldFNWR0F0dHJpYnV0ZSh0aGlzLl9jb2xvcml6ZVNWR0ljb24oXG4gICAgICAgIC8vIEljb25zIHByb3ZpZGVkIGJ5IGFudCBkZXNpZ24gc2hvdWxkIGJlIHJlZmluZWQgdG8gcmVtb3ZlIHByZXNldCBjb2xvcnMuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNWR0VsZW1lbnRGcm9tU3RyaW5nKGhhc05hbWVzcGFjZShpY29uLm5hbWUpID8gaWNvbi5pY29uIDogcmVwbGFjZUZpbGxDb2xvcihpY29uLmljb24pKSxcbiAgICAgICAgaWNvbi50aGVtZSA9PT0gJ3R3b3RvbmUnLFxuICAgICAgICBwcmksXG4gICAgICAgIHNlY1xuICAgICAgKSk7XG4gICAgICAvLyBDYWNoZSBpdC5cbiAgICAgIHRoaXMuX3N2Z1JlbmRlcmVkRGVmaW5pdGlvbnMuc2V0KGtleSwgeyAuLi5pY29uLCBpY29uOiBzdmcgfSBhcyBDYWNoZWRJY29uRGVmaW5pdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lU1ZHKHN2Zyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZVNWR0VsZW1lbnRGcm9tU3RyaW5nKHN0cjogc3RyaW5nKTogU1ZHRWxlbWVudCB7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9IHN0cjtcbiAgICBjb25zdCBzdmc6IFNWR0VsZW1lbnQgPSBkaXYucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgaWYgKCFzdmcpIHsgdGhyb3cgU1ZHVGFnTm90Rm91bmRFcnJvcjsgfVxuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFNWR0F0dHJpYnV0ZShzdmc6IFNWR0VsZW1lbnQpOiBTVkdFbGVtZW50IHtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnd2lkdGgnLCAnMWVtJyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHN2ZywgJ2hlaWdodCcsICcxZW0nKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb2xvcml6ZVNWR0ljb24oc3ZnOiBTVkdFbGVtZW50LCB0d290b25lOiBib29sZWFuLCBwcmk6IHN0cmluZywgc2VjOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBpZiAodHdvdG9uZSkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGROb2RlcztcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQ6IEhUTUxFbGVtZW50ID0gY2hpbGRyZW5bIGkgXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZSgnZmlsbCcpID09PSAnc2Vjb25kYXJ5Q29sb3InKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGNoaWxkLCAnZmlsbCcsIHNlYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGNoaWxkLCAnZmlsbCcsIHByaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHN2ZywgJ2ZpbGwnLCAnY3VycmVudENvbG9yJyk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxufVxuIl19